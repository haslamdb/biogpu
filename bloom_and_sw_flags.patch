--- clean_resistance_pipeline_main.cpp.orig
+++ clean_resistance_pipeline_main.cpp
@@ -149,6 +149,10 @@ private:
     const int batch_size = 10000;
     const int max_read_length = 300;
     const int bloom_min_kmers = 3;
+    
+    // Configuration flags
+    bool use_bloom_filter = true;        // Enable bloom filtering by default
+    bool use_smith_waterman = true;      // Enable Smith-Waterman by default
     const int kmer_length = 15;
     const int max_candidates_per_read = 64;
     const int max_protein_matches_per_read = 32;
@@ -165,17 +169,24 @@ private:
     } stats;
 
 public:
-    CleanResistancePipeline() {
+    CleanResistancePipeline(bool enable_bloom = true, bool enable_sw = true) 
+        : use_bloom_filter(enable_bloom), use_smith_waterman(enable_sw) {
+        
         std::cout << "Initializing Clean Resistance Detection Pipeline\n";
+        std::cout << "  Bloom filter: " << (use_bloom_filter ? "ENABLED" : "DISABLED") << "\n";
+        std::cout << "  Smith-Waterman: " << (use_smith_waterman ? "ENABLED" : "DISABLED") << "\n";
         
-        // Create bloom filter
-        bloom_filter = create_bloom_filter(kmer_length);
-        if (!bloom_filter) {
-            throw std::runtime_error("Failed to create bloom filter");
+        // Only create bloom filter if enabled
+        if (use_bloom_filter) {
+            bloom_filter = create_bloom_filter(kmer_length);
+            if (!bloom_filter) {
+                throw std::runtime_error("Failed to create bloom filter");
+            }
+        } else {
+            bloom_filter = nullptr;
         }
         
-        // Create translated search engine with Smith-Waterman
-        translated_search_engine = create_translated_search_engine_with_sw(batch_size, true);
+        // Create translated search engine with configurable Smith-Waterman
+        translated_search_engine = create_translated_search_engine_with_sw(batch_size, use_smith_waterman);
         if (!translated_search_engine) {
             throw std::runtime_error("Failed to create translated search engine");
         }
@@ -243,6 +254,26 @@ public:
         cudaFree(d_protein_match_counts);
     }
     
+    void setBloomFilterEnabled(bool enabled) {
+        if (enabled && !bloom_filter) {
+            bloom_filter = create_bloom_filter(kmer_length);
+            if (!bloom_filter) {
+                std::cerr << "Warning: Failed to create bloom filter\n";
+                use_bloom_filter = false;
+                return;
+            }
+        } else if (!enabled && bloom_filter) {
+            destroy_bloom_filter(bloom_filter);
+            bloom_filter = nullptr;
+        }
+        use_bloom_filter = enabled;
+        std::cout << "Bloom filter " << (enabled ? "ENABLED" : "DISABLED") << "\n";
+    }
+    
+    void setSmithWatermanEnabled(bool enabled) {
+        use_smith_waterman = enabled;
+        if (translated_search_engine) {
+            set_smith_waterman_enabled(translated_search_engine, enabled);
+        }
+        std::cout << "Smith-Waterman " << (enabled ? "ENABLED" : "DISABLED") << "\n";
+    }
+    
     void loadDatabases(const std::string& nucleotide_index_path, 
                       const std::string& protein_db_path,
@@ -565,18 +596,20 @@ private:
         CUDA_CHECK(cudaMemset(d_protein_match_counts, 0, num_reads * sizeof(uint32_t)));
         
         // Stage 1: Bloom filter screening
-        int bloom_result_r1 = bloom_filter_screen_reads_with_rc(
-            bloom_filter, d_reads_r1, d_lengths_r1, d_offsets_r1,
-            num_reads, d_bloom_passes_r1, d_bloom_kmers_r1,
-            bloom_min_kmers, false, nullptr
-        );
-        
-        int bloom_result_r2 = bloom_filter_screen_reads_with_rc(
-            bloom_filter, d_reads_r2, d_lengths_r2, d_offsets_r2,
-            num_reads, d_bloom_passes_r2, d_bloom_kmers_r2,
-            bloom_min_kmers, true, nullptr
-        );
-        
+        if (use_bloom_filter && bloom_filter) {
+            int bloom_result_r1 = bloom_filter_screen_reads_with_rc(
+                bloom_filter, d_reads_r1, d_lengths_r1, d_offsets_r1,
+                num_reads, d_bloom_passes_r1, d_bloom_kmers_r1,
+                bloom_min_kmers, false, nullptr
+            );
+            
+            int bloom_result_r2 = bloom_filter_screen_reads_with_rc(
+                bloom_filter, d_reads_r2, d_lengths_r2, d_offsets_r2,
+                num_reads, d_bloom_passes_r2, d_bloom_kmers_r2,
+                bloom_min_kmers, true, nullptr
+            );
+        
         // Get bloom results
         std::vector<uint8_t> h_bloom_r1(num_reads), h_bloom_r2(num_reads);
         CUDA_CHECK(cudaMemcpy(h_bloom_r1.data(), d_bloom_passes_r1, num_reads * sizeof(bool), cudaMemcpyDeviceToHost));
@@ -588,6 +621,12 @@ private:
                 stats.bloom_passed++;
             }
         }
+        } else {
+            // If bloom filtering is disabled, mark all reads as passed
+            CUDA_CHECK(cudaMemset(d_bloom_passes_r1, 1, num_reads * sizeof(bool)));
+            CUDA_CHECK(cudaMemset(d_bloom_passes_r2, 1, num_reads * sizeof(bool)));
+            stats.bloom_passed += num_reads;
+        }
         
         // Stage 2: Nucleotide k-mer matching
         launch_kmer_filter(d_reads_r1, d_lengths_r1, d_offsets_r1,
@@ -779,15 +818,29 @@ private:
 
 int main(int argc, char* argv[]) {
     if (argc < 7) {
-        std::cerr << "Usage: " << argv[0] << " <r1.fq.gz> <r2.fq.gz> <nucleotide_index> <protein_db> <fq_csv> <output_prefix>\n";
+        std::cerr << "Usage: " << argv[0] << " <r1.fq.gz> <r2.fq.gz> <nucleotide_index> <protein_db> <fq_csv> <output_prefix> [--no-bloom] [--no-sw]\n";
         return 1;
     }
     
+    // Parse optional flags
+    bool use_bloom = true;
+    bool use_sw = true;
+    
+    for (int i = 7; i < argc; i++) {
+        std::string arg(argv[i]);
+        if (arg == "--no-bloom") {
+            use_bloom = false;
+        } else if (arg == "--no-sw") {
+            use_sw = false;
+        }
+    }
+    
     try {
-        CleanResistancePipeline pipeline;
+        CleanResistancePipeline pipeline(use_bloom, use_sw);
         
         std::string r1_path(argv[1]);
         std::string r2_path(argv[2]);
--- translated_search_revised.cu.orig
+++ translated_search_revised.cu
@@ -26,7 +26,7 @@
 #define CODON_SIZE 3
 #define NUM_FRAMES 6
 #define MAX_PROTEIN_LENGTH 200
-#define PROTEIN_KMER_SIZE 5         // Increased from 3 to 5 amino acids
+#define PROTEIN_KMER_SIZE 8         // Increased from 5 to 8 amino acids for better specificity
 #define MIN_PEPTIDE_LENGTH 20       // Minimum peptide length to consider
 #define MIN_SEED_HITS 1            // Require only one k-mer hit for extension
 #define EXTENSION_THRESHOLD 15     // Minimum amino acids for valid match
@@ -101,10 +101,10 @@ __device__ inline float get_blosum_score(char aa1, char aa2) {
 
 // Enhanced 5-mer hashing for protein sequences
 __device__ inline uint64_t hash_protein_5mer(const char* seq) {
-    // Simple but effective hash for 5 amino acids
+    // Simple but effective hash for protein k-mers
     uint64_t hash = 0;
     
-    for (int i = 0; i < 5; i++) {
+    for (int i = 0; i < PROTEIN_KMER_SIZE; i++) {
         int aa_idx = aa_to_index(seq[i]);
         if (aa_idx >= AA_ALPHABET_SIZE) return UINT64_MAX; // Invalid sequence
         hash = hash * 31 + aa_idx;
@@ -464,12 +464,12 @@ __global__ void enhanced_protein_kmer_match_kernel(
         
         if (frame.length < PROTEIN_KMER_SIZE) continue;
         
-        // Collect 5-mer seed hits
+        // Collect k-mer seed hits
         SeedHit seeds[100];
         int num_seeds = 0;
         
-        // Find 5-mer seed matches
+        // Find k-mer seed matches
         for (int pos = 0; pos + PROTEIN_KMER_SIZE <= frame.length && num_seeds < 100; pos++) {
-            uint64_t kmer_hash = hash_protein_5mer(&frame.sequence[pos]);
+            uint64_t kmer_hash = hash_protein_kmer(&frame.sequence[pos]);
             
             int kmer_idx = binary_search_protein_kmer(protein_db, kmer_hash);
             if (kmer_idx >= 0) {
@@ -927,7 +927,7 @@ public:
             }
         }
         
-        // Extract and sort 5-mers with positions
+        // Extract and sort k-mers with positions
         std::vector<std::pair<uint64_t, uint32_t>> kmer_positions;
         
         for (uint32_t p = 0; p < num_proteins; p++) {
@@ -938,8 +938,8 @@ public:
             }
             
             for (uint32_t pos = 0; pos + PROTEIN_KMER_SIZE <= len; pos++) {
-                // Hash the 5-mer
-                uint64_t hash = hash_protein_5mer_host(&sequences[start + pos]);
+                // Hash the k-mer
+                uint64_t hash = hash_protein_kmer_host(&sequences[start + pos]);
                 if (hash == UINT64_MAX) continue;
                 
                 // Encode protein ID and position
@@ -948,7 +948,7 @@ public:
             }
         }
         
-        DEBUG_PRINT("Extracted %zu total 5-mer positions", kmer_positions.size());
+        DEBUG_PRINT("Extracted %zu total %d-mer positions", kmer_positions.size(), PROTEIN_KMER_SIZE);
         
         // Sort by k-mer hash
         std::sort(kmer_positions.begin(), kmer_positions.end(),
@@ -1058,7 +1058,7 @@ public:
         err = cudaMemcpy(d_protein_db, &h_db, sizeof(ProteinDatabase), cudaMemcpyHostToDevice);
         if (err != cudaSuccess) return false;
         
-        DEBUG_PRINT("Enhanced protein database loaded: %d proteins, %d unique 5-mers, SW=%s", 
+        DEBUG_PRINT("Enhanced protein database loaded: %d proteins, %d unique %d-mers, SW=%s", 
                    num_proteins, (int)sorted_hashes.size(), smith_waterman_enabled ? "enabled" : "disabled");
         return true;
     }
@@ -1114,7 +1114,7 @@ public:
             return;
         }
         
-        // Stage 2: Enhanced 5-mer protein matching with optional Smith-Waterman
+        // Stage 2: Enhanced k-mer protein matching with optional Smith-Waterman
         enhanced_protein_kmer_match_kernel<<<grid_size, block_size>>>(
             d_translated_frames, d_frame_counts,
             num_reads, d_protein_db,